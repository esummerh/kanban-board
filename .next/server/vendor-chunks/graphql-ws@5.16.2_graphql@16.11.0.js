"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws@5.16.2_graphql@16.11.0";
exports.ids = ["vendor-chunks/graphql-ws@5.16.2_graphql@16.11.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/client.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/client.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n *\n * client\n *\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TerminatedCloseEvent = void 0;\nexports.createClient = createClient;\nconst common_1 = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js\");\n/** This file is the entry point for browsers, re-export common elements. */\n__exportStar(__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js\"), exports);\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send((0, common_1.stringifyMessage)({ type: common_1.MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send((0, common_1.stringifyMessage)(payload\n                        ? {\n                            type: common_1.MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: common_1.MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(common_1.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(common_1.CloseCode.InternalClientError, (0, utils_1.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = (0, common_1.parseMessage)(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send((0, common_1.stringifyMessage)(message.payload\n                                ? {\n                                    type: common_1.MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: common_1.MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== common_1.MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(common_1.CloseCode.BadResponse, (0, utils_1.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    common_1.CloseCode.InternalServerError,\n                    common_1.CloseCode.InternalClientError,\n                    common_1.CloseCode.BadRequest,\n                    common_1.CloseCode.BadResponse,\n                    common_1.CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    common_1.CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    common_1.CloseCode.SubscriberAlreadyExists,\n                    common_1.CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case common_1.MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case common_1.MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case common_1.MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send((0, common_1.stringifyMessage)({\n                        id,\n                        type: common_1.MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send((0, common_1.stringifyMessage)({\n                                id,\n                                type: common_1.MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A synthetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nclass TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nexports.TerminatedCloseEvent = TerminatedCloseEvent;\nfunction isLikeCloseEvent(val) {\n    return (0, utils_1.isObject)(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000, // Normal Closure is not an erroneous close code\n        1001, // Going Away\n        1006, // Abnormal Closure\n        1005, // No Status Received\n        1012, // Service Restart\n        1013, // Try Again Later\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQixpQkFBaUIsbUJBQU8sQ0FBQyxvSEFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrSEFBUztBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvSEFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osK0JBQStCO0FBQy9CLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDRDQUE0QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EseUVBQXlFLGlDQUFpQztBQUMxRztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsc0NBQXNDO0FBQ3RDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZWxsYXN1bW1lcmhpbGwvRGVza3RvcC9teWNyaXR0ZXJzL2thbmJhbi1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqXG4gKiBjbGllbnRcbiAqXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGVybWluYXRlZENsb3NlRXZlbnQgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGJyb3dzZXJzLCByZS1leHBvcnQgY29tbW9uIGVsZW1lbnRzLiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1vblwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIENyZWF0ZXMgYSBkaXNwb3NhYmxlIEdyYXBoUUwgb3ZlciBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVybCwgY29ubmVjdGlvblBhcmFtcywgbGF6eSA9IHRydWUsIG9uTm9uTGF6eUVycm9yID0gY29uc29sZS5lcnJvciwgbGF6eUNsb3NlVGltZW91dDogbGF6eUNsb3NlVGltZW91dE1zID0gMCwga2VlcEFsaXZlID0gMCwgZGlzYWJsZVBvbmcsIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCA9IDAsIHJldHJ5QXR0ZW1wdHMgPSA1LCByZXRyeVdhaXQgPSBhc3luYyBmdW5jdGlvbiByYW5kb21pc2VkRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJpZXMpIHtcbiAgICAgICAgbGV0IHJldHJ5RGVsYXkgPSAxMDAwOyAvLyBzdGFydCB3aXRoIDFzIGRlbGF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5ICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSArXG4gICAgICAgICAgICAvLyBhZGQgcmFuZG9tIHRpbWVvdXQgZnJvbSAzMDBtcyB0byAzc1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDMwMDAgLSAzMDApICsgMzAwKSkpO1xuICAgIH0sIHNob3VsZFJldHJ5ID0gaXNMaWtlQ2xvc2VFdmVudCwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtLCBvbiwgd2ViU29ja2V0SW1wbCwgXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdjQgVVVJRCB0byBiZSB1c2VkIGFzIHRoZSBJRCB1c2luZyBgTWF0aGBcbiAgICAgKiBhcyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFN1cHBseSB5b3VyIG93biBnZW5lcmF0b3JcbiAgICAgKiBpbiBjYXNlIHlvdSBuZWVkIG1vcmUgdW5pcXVlbmVzcy5cbiAgICAgKlxuICAgICAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgICAqL1xuICAgIGdlbmVyYXRlSUQgPSBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9LCBqc29uTWVzc2FnZVJlcGxhY2VyOiByZXBsYWNlciwganNvbk1lc3NhZ2VSZXZpdmVyOiByZXZpdmVyLCB9ID0gb3B0aW9ucztcbiAgICBsZXQgd3M7XG4gICAgaWYgKHdlYlNvY2tldEltcGwpIHtcbiAgICAgICAgaWYgKCFpc1dlYlNvY2tldCh3ZWJTb2NrZXRJbXBsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHdzID0gd2ViU29ja2V0SW1wbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPSBXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIGdsb2JhbC5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICBnbG9iYWwuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9XG4gICAgICAgICAgICB3aW5kb3cuV2ViU29ja2V0IHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgd2luZG93Lk1veldlYlNvY2tldDtcbiAgICB9XG4gICAgaWYgKCF3cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIG1pc3Npbmc7IG9uIE5vZGUgeW91IGNhbiBgaW1wb3J0IFdlYlNvY2tldCBmcm9tICd3cyc7YCBhbmQgcGFzcyBgd2ViU29ja2V0SW1wbDogV2ViU29ja2V0YCB0byBgY3JlYXRlQ2xpZW50YFwiKTtcbiAgICBjb25zdCBXZWJTb2NrZXRJbXBsID0gd3M7XG4gICAgLy8gd2Vic29ja2V0IHN0YXR1cyBlbWl0dGVyLCBzdWJzY3JpcHRpb25zIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5XG4gICAgY29uc3QgZW1pdHRlciA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uKGlkLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtaXQobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnaWQnIGluIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lcnNbbWVzc2FnZS5pZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVycywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY29ubmVjdGluZykgPyBbb24uY29ubmVjdGluZ10gOiBbXSxcbiAgICAgICAgICAgIG9wZW5lZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5vcGVuZWQpID8gW29uLm9wZW5lZF0gOiBbXSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0ZWQpID8gW29uLmNvbm5lY3RlZF0gOiBbXSxcbiAgICAgICAgICAgIHBpbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucGluZykgPyBbb24ucGluZ10gOiBbXSxcbiAgICAgICAgICAgIHBvbmc6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ucG9uZykgPyBbb24ucG9uZ10gOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24ubWVzc2FnZSkgPyBbbWVzc2FnZS5lbWl0LCBvbi5tZXNzYWdlXSA6IFttZXNzYWdlLmVtaXRdLFxuICAgICAgICAgICAgY2xvc2VkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNsb3NlZCkgPyBbb24uY2xvc2VkXSA6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uZXJyb3IpID8gW29uLmVycm9yXSA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25NZXNzYWdlOiBtZXNzYWdlLm9uLFxuICAgICAgICAgICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgbC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsLnNwbGljZShsLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3B5IHRoZSBsaXN0ZW5lcnMgc28gdGhhdCB1bmxpc3RlbnMgZG9udCBcInB1bGwgdGhlIHJ1ZyB1bmRlciBvdXIgZmVldFwiXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4ubGlzdGVuZXJzW2V2ZW50XV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVGhlIGFyZ3Mgc2hvdWxkIGZpdFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLy8gaW52b2tlcyB0aGUgY2FsbGJhY2sgZWl0aGVyIHdoZW4gYW4gZXJyb3Igb3IgY2xvc2VkIGV2ZW50IGlzIGVtaXR0ZWQsXG4gICAgLy8gZmlyc3Qgb25lIHRoYXQgZ2V0cyBjYWxsZWQgcHJldmFpbHMsIG90aGVyIGVtaXNzaW9ucyBhcmUgaWdub3JlZFxuICAgIGZ1bmN0aW9uIGVycm9yT3JDbG9zZWQoY2IpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuaW5nID0gW1xuICAgICAgICAgICAgLy8gZXJyb3JzIGFyZSBmYXRhbCBhbmQgbW9yZSBjcml0aWNhbCB0aGFuIGNsb3NlIGV2ZW50cywgdGhyb3cgdGhlbSBmaXJzdFxuICAgICAgICAgICAgZW1pdHRlci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvLyBjbG9zZXMgY2FuIGJlIGdyYWNlZnVsIGFuZCBub3QgZmF0YWwsIHRocm93IHRoZW0gc2Vjb25kIChpZiBlcnJvciBkaWRudCB0aHJvdylcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ2Nsb3NlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmluZy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgICAgICAgICAgICAgY2IoZXZlbnQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGxldCBjb25uZWN0aW5nLCBsb2NrcyA9IDAsIGxhenlDbG9zZVRpbWVvdXQsIHJldHJ5aW5nID0gZmFsc2UsIHJldHJpZXMgPSAwLCBkaXNwb3NlZCA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXp5IGNsb3NlIHRpbWVvdXQgaW1tZWRpYXRlbGx5IHNvIHRoYXQgY2xvc2UgZ2V0cyBkZWJvdW5jZWRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvaXNzdWVzLzM4OFxuICAgICAgICBjbGVhclRpbWVvdXQobGF6eUNsb3NlVGltZW91dCk7XG4gICAgICAgIGNvbnN0IFtzb2NrZXQsIHRocm93T25DbG9zZV0gPSBhd2FpdCAoY29ubmVjdGluZyAhPT0gbnVsbCAmJiBjb25uZWN0aW5nICE9PSB2b2lkIDAgPyBjb25uZWN0aW5nIDogKGNvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZSgoY29ubmVjdGVkLCBkZW5pZWQpID0+IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmV0cnlpbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXRyeVdhaXQocmV0cmllcyk7XG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9ucyBtaWdodCBjb21wbGV0ZSB3aGlsZSB3YWl0aW5nIGZvciByZXRyeVxuICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbmllZCh7IGNvZGU6IDEwMDAsIHJlYXNvbjogJ0FsbCBTdWJzY3JpcHRpb25zIEdvbmUnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nvbm5lY3RpbmcnLCByZXRyeWluZyk7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgV2ViU29ja2V0SW1wbCh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nID8gYXdhaXQgdXJsKCkgOiB1cmwsIGNvbW1vbl8xLkdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MKTtcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uQWNrVGltZW91dCwgcXVldWVkUGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVucXVldWVQaW5nKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShrZWVwQWxpdmUpICYmIGtlZXBBbGl2ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpOyAvLyBpbiBjYXNlIHdoZXJlIGEgcG9uZyB3YXMgcmVjZWl2ZWQgYmVmb3JlIGEgcGluZyAodGhpcyBpcyB2YWxpZCBiZWhhdmlvdXIpXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZFBpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoKDAsIGNvbW1vbl8xLnN0cmluZ2lmeU1lc3NhZ2UpKHsgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuUGluZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwaW5nJywgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGtlZXBBbGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JPckNsb3NlZCgoZXJyT3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocXVldWVkUGluZyk7XG4gICAgICAgICAgICAgICAgZGVuaWVkKGVyck9yRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJPckV2ZW50IGluc3RhbmNlb2YgVGVybWluYXRlZENsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKDQ0OTksICdUZXJtaW5hdGVkJyk7IC8vIGNsb3NlIGV2ZW50IGlzIGFydGlmaWNpYWwgYW5kIGVtaXR0ZWQgbWFudWFsbHksIHNlZSBgQ2xpZW50LnRlcm1pbmF0ZSgpYCBiZWxvd1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvY2tldC5vbmVycm9yID0gKGVycikgPT4gZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4gZW1pdHRlci5lbWl0KCdjbG9zZWQnLCBldmVudCk7XG4gICAgICAgICAgICBzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnb3BlbmVkJywgc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHR5cGVvZiBjb25uZWN0aW9uUGFyYW1zID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IGNvbm5lY3Rpb25QYXJhbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25uZWN0aW9uUGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uUGFyYW1zIG1pZ2h0IHRha2UgdG9vIGxvbmcgY2F1c2luZyB0aGUgc2VydmVyIHRvIGtpY2sgb2ZmIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5lY2Vzc2FyeSBlcnJvci9jbG9zZSBldmVudCBpcyBhbHJlYWR5IHJlcG9ydGVkIC0gc2ltcGx5IHN0b3AgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkocGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoY29tbW9uXzEuQ2xvc2VDb2RlLkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0LCAnQ29ubmVjdGlvbiBhY2tub3dsZWRnZW1lbnQgdGltZW91dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlUGluZygpOyAvLyBlbnF1ZXVlIHBpbmcgKG5vb3AgaWYgZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvciwgKDAsIHV0aWxzXzEubGltaXRDbG9zZVJlYXNvbikoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IG5ldyBFcnJvcihlcnIpLm1lc3NhZ2UsICdJbnRlcm5hbCBjbGllbnQgZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY2tub3dsZWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKDAsIGNvbW1vbl8xLnBhcnNlTWVzc2FnZSkoZGF0YSwgcmV2aXZlcik7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAncGluZycgfHwgbWVzc2FnZS50eXBlID09PSAncG9uZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChtZXNzYWdlLnR5cGUsIHRydWUsIG1lc3NhZ2UucGF5bG9hZCk7IC8vIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAncG9uZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlUGluZygpOyAvLyBlbnF1ZXVlIG5leHQgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkaXNhYmxlUG9uZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgd2l0aCBwb25nIG9uIHBpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwb25nJywgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHBpbmcgYW5kIHBvbmdzIGNhbiBiZSByZWNlaXZlZCB3aGVuZXZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY29ubmVjdGVkIGFuZCBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gY29tbW9uXzEuTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0ZWQnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCwgcmV0cnlpbmcpOyAvLyBjb25uZWN0ZWQgPSBzb2NrZXQgb3BlbmVkICsgYWNrbm93bGVkZ2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7IC8vIGZ1dHVyZSBsYXp5IGNvbm5lY3RzIGFyZSBub3QgcmV0cmllc1xuICAgICAgICAgICAgICAgICAgICByZXRyaWVzID0gMDsgLy8gcmVzZXQgdGhlIHJldHJpZXMgb24gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gZXJyb3JPckNsb3NlZChyZWplY3QpKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG51bGw7IC8vIHN0b3AgcmVhZGluZyBtZXNzYWdlcyBhcyBzb29uIGFzIHJlYWRpbmcgYnJlYWtzIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuQmFkUmVzcG9uc2UsICgwLCB1dGlsc18xLmxpbWl0Q2xvc2VSZWFzb24pKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnQmFkIHJlc3BvbnNlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCkpKSk7XG4gICAgICAgIC8vIGlmIHRoZSBwcm92aWRlZCBzb2NrZXQgaXMgaW4gYSBjbG9zaW5nIHN0YXRlLCB3YWl0IGZvciB0aGUgdGhyb3cgb24gY2xvc2VcbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLkNMT1NJTkcpXG4gICAgICAgICAgICBhd2FpdCB0aHJvd09uQ2xvc2U7XG4gICAgICAgIGxldCByZWxlYXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gcmVsZWFzZXMgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbGVhc2VkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IChyZWxlYXNlID0gcmVzb2x2ZSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgcmVsZWFzZSxcbiAgICAgICAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3JcbiAgICAgICAgICAgICAgICByZWxlYXNlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vIG1vcmUgbG9ja3MgYXJlIHByZXNlbnQsIGNvbXBsZXRlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHNvY2tldC5jbG9zZSgxMDAwLCAnTm9ybWFsIENsb3N1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShsYXp5Q2xvc2VUaW1lb3V0TXMpICYmIGxhenlDbG9zZVRpbWVvdXRNcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUga2VlcGFsaXZlIGlzIHNldCwgYWxsb3cgZm9yIHRoZSBzcGVjaWZpZWQgY2FsbWRvd24gdGltZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGNvbXBsZXRlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgb3Blbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXp5Q2xvc2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsYXp5Q2xvc2VUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbXBsZXRlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8vIG9yXG4gICAgICAgICAgICAgICAgdGhyb3dPbkNsb3NlLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgYGNvbm5lY3RgIHByb2JsZW0gYW5kIGV2YWx1YXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAvLyBzb21lIGNsb3NlIGNvZGVzIGFyZSB3b3J0aCByZXBvcnRpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJlxuICAgICAgICAgICAgKGlzRmF0YWxJbnRlcm5hbENsb3NlQ29kZShlcnJPckNsb3NlRXZlbnQuY29kZSkgfHxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbl8xLkNsb3NlQ29kZS5JbnRlcm5hbFNlcnZlckVycm9yLFxuICAgICAgICAgICAgICAgICAgICBjb21tb25fMS5DbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uXzEuQ2xvc2VDb2RlLkJhZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbl8xLkNsb3NlQ29kZS5CYWRSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uXzEuQ2xvc2VDb2RlLlVuYXV0aG9yaXplZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkZvcmJpZGRlbiwgbWlnaHQgZ3JhbnQgYWNjZXNzIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBjb21tb25fMS5DbG9zZUNvZGUuU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbl8xLkNsb3NlQ29kZS5TdWJzY3JpYmVyQWxyZWFkeUV4aXN0cyxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uXzEuQ2xvc2VDb2RlLlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzLFxuICAgICAgICAgICAgICAgICAgICAvLyA0NDk5LCAvLyBUZXJtaW5hdGVkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBzb2NrZXQgZnJvemUsIHdlIHdhbnQgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGVyck9yQ2xvc2VFdmVudC5jb2RlKSkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIGNsaWVudCB3YXMgZGlzcG9zZWQsIG5vIHJldHJpZXMgc2hvdWxkIHByb2NlZWQgcmVnYXJkbGVzc1xuICAgICAgICBpZiAoZGlzcG9zZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIG5vcm1hbCBjbG9zdXJlIChwb3NzaWJseSBhbGwgc3Vic2NyaXB0aW9ucyBoYXZlIGNvbXBsZXRlZClcbiAgICAgICAgLy8gaWYgbm8gbG9ja3Mgd2VyZSBhY3F1aXJlZCBpbiB0aGUgbWVhbnRpbWUsIHNob3VsZG50IHRyeSBhZ2FpblxuICAgICAgICBpZiAoaXNMaWtlQ2xvc2VFdmVudChlcnJPckNsb3NlRXZlbnQpICYmIGVyck9yQ2xvc2VFdmVudC5jb2RlID09PSAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGxvY2tzID4gMDtcbiAgICAgICAgLy8gcmV0cmllcyBhcmUgbm90IGFsbG93ZWQgb3Igd2UgdHJpZWQgdG8gbWFueSB0aW1lcywgcmVwb3J0IGVycm9yXG4gICAgICAgIGlmICghcmV0cnlBdHRlbXB0cyB8fCByZXRyaWVzID49IHJldHJ5QXR0ZW1wdHMpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIHRocm93IG5vbi1yZXRyeWFibGUgY29ubmVjdGlvbiBwcm9ibGVtc1xuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyck9yQ2xvc2VFdmVudCkpXG4gICAgICAgICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgICAgIC8vIEBkZXByZWNhdGVkIHRocm93IGZhdGFsIGNvbm5lY3Rpb24gcHJvYmxlbXMgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSA9PT0gbnVsbCB8fCBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbShlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBsb29rcyBnb29kLCBzdGFydCByZXRyeWluZ1xuICAgICAgICByZXR1cm4gKHJldHJ5aW5nID0gdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGluIG5vbi1sYXp5IChob3Q/KSBtb2RlIGFsd2F5cyBob2xkIG9uZSBjb25uZWN0aW9uIGxvY2sgdG8gcGVyc2lzdCB0aGUgc29ja2V0XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2NrcysrO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssICwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhyb3dPbkNsb3NlOyAvLyB3aWxsIGFsd2F5cyB0aHJvdyBiZWNhdXNlIHJlbGVhc2VyIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBvcnQgdGhyb3duIGVycm9yLCBubyBmdXJ0aGVyIHJldHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbk5vbkxhenlFcnJvciA9PT0gbnVsbCB8fCBvbk5vbkxhenlFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Ob25MYXp5RXJyb3IoZXJyT3JDbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHBheWxvYWQsIHNpbmspIHtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlEKHBheWxvYWQpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlLCBlcnJvcmVkID0gZmFsc2UsIHJlbGVhc2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9yIGhhbmRsaW5nIGNvbXBsZXRpb25zIGJlZm9yZSBjb25uZWN0XG4gICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2NrcysrO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzb2NrZXQsIHJlbGVhc2UsIHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2VdID0gYXdhaXQgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkb25lIHdoaWxlIHdhaXRpbmcgZm9yIGNvbm5lY3QsIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb24gbG9jayByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5saXN0ZW4gPSBlbWl0dGVyLm9uTWVzc2FnZShpZCwgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb21tb25fMS5NZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIHBheWxvYWQgd2lsbCBmaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLm5leHQobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvcmVkID0gdHJ1ZSksIChkb25lID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsuZXJyb3IobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlcigpOyAvLyByZWxlYXNlIGNvbXBsZXRlcyB0aGUgc2lua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoKDAsIGNvbW1vbl8xLnN0cmluZ2lmeU1lc3NhZ2UpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuU3Vic2NyaWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgY29tcGxldGVkIGFscmVhZHkgYW5kIHNvY2tldCBpcyBvcGVuLCBzZW5kIGNvbXBsZXRlIG1lc3NhZ2UgdG8gc2VydmVyIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoZSByZWxlYXNlciB3aWxsIGJlIGNhbGxlZCwgY29ubmVjdGlvbiBjb21wbGV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIHJlc29sdmVkIG9yIHRoZSBzb2NrZXQgY2xvc2VkIGFuZCB0aGUgcHJvbWlzZSByZWplY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgaGFwcGVucyB0aG91Z2gsIHdlIHdhbnQgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2UuZmluYWxseSh1bmxpc3Rlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY29tcGxldGVkLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGRlbGl2ZXJpbmcgZWl0aGVyIGFuIGVycm9yIG9yIGEgY29tcGxldGUgdGVybWluYXRlcyB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICghZXJyb3JlZClcbiAgICAgICAgICAgICAgICBzaW5rLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pIC8vIHJlc29sdmVzIG9uIHJlbGVhc2Ugb3Igbm9ybWFsIGNsb3N1cmVcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH0pOyAvLyByZWplY3RzIG9uIGNsb3NlIGV2ZW50cyBhbmQgZXJyb3JzXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBkaXNwb3NlIG9ubHkgb2YgYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvbjogZW1pdHRlci5vbixcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBpdGVyYXRlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0ge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zZSA9IHN1YnNjcmliZShyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gcGF5bG9hZCB3aWxsIGZpdCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IChmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyYXRvcl8xKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3YWl0IGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nIG1lc3NhZ2VzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IChkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZsdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocGVuZGluZy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZlcnJlZC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlZmVycmVkLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLnRocm93ID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uLCBjbG9zZSBpdFxuICAgICAgICAgICAgICAgIGNvbnN0IFtzb2NrZXRdID0gYXdhaXQgY29ubmVjdGluZztcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoMTAwMCwgJ05vcm1hbCBDbG9zdXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nsb3NlZCcsIG5ldyBUZXJtaW5hdGVkQ2xvc2VFdmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBBIHN5bnRoZXRpYyBjbG9zZSBldmVudCBgNDQ5OTogVGVybWluYXRlZGAgaXMgaXNzdWVkIHRvIHRoZSBjdXJyZW50IHRvIGltbWVkaWF0ZWx5XG4gKiBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvbmUgY29taW5nIGZyb20gYFdlYlNvY2tldC5vbmNsb3NlYC5cbiAqXG4gKiBUZXJtaW5hdGluZyBpcyBub3QgY29uc2lkZXJlZCBmYXRhbCBhbmQgYSBjb25uZWN0aW9uIHJldHJ5IHdpbGwgb2NjdXIgYXMgZXhwZWN0ZWQuXG4gKlxuICogVXNlZnVsIGluIGNhc2VzIHdoZXJlIHRoZSBXZWJTb2NrZXQgaXMgc3R1Y2sgYW5kIG5vdCBlbWl0dGluZyBhbnkgZXZlbnRzO1xuICogY2FuIGhhcHBlbiBvbiBpT1MgU2FmYXJpLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9kaXNjdXNzaW9ucy8yOTAuXG4gKi9cbmNsYXNzIFRlcm1pbmF0ZWRDbG9zZUV2ZW50IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGVybWluYXRlZENsb3NlRXZlbnQnO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnNDQ5OTogVGVybWluYXRlZCc7XG4gICAgICAgIHRoaXMuY29kZSA9IDQ0OTk7XG4gICAgICAgIHRoaXMucmVhc29uID0gJ1Rlcm1pbmF0ZWQnO1xuICAgICAgICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5UZXJtaW5hdGVkQ2xvc2VFdmVudCA9IFRlcm1pbmF0ZWRDbG9zZUV2ZW50O1xuZnVuY3Rpb24gaXNMaWtlQ2xvc2VFdmVudCh2YWwpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaXNPYmplY3QpKHZhbCkgJiYgJ2NvZGUnIGluIHZhbCAmJiAncmVhc29uJyBpbiB2YWw7XG59XG5mdW5jdGlvbiBpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoY29kZSkge1xuICAgIGlmIChbXG4gICAgICAgIDEwMDAsIC8vIE5vcm1hbCBDbG9zdXJlIGlzIG5vdCBhbiBlcnJvbmVvdXMgY2xvc2UgY29kZVxuICAgICAgICAxMDAxLCAvLyBHb2luZyBBd2F5XG4gICAgICAgIDEwMDYsIC8vIEFibm9ybWFsIENsb3N1cmVcbiAgICAgICAgMTAwNSwgLy8gTm8gU3RhdHVzIFJlY2VpdmVkXG4gICAgICAgIDEwMTIsIC8vIFNlcnZpY2UgUmVzdGFydFxuICAgICAgICAxMDEzLCAvLyBUcnkgQWdhaW4gTGF0ZXJcbiAgICAgICAgMTAxNCwgLy8gQmFkIEdhdGV3YXlcbiAgICBdLmluY2x1ZGVzKGNvZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWxsIG90aGVyIGludGVybmFsIGVycm9ycyBhcmUgZmF0YWxcbiAgICByZXR1cm4gY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gMTk5OTtcbn1cbmZ1bmN0aW9uIGlzV2ViU29ja2V0KHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAnY29uc3RydWN0b3InIGluIHZhbCAmJlxuICAgICAgICAnQ0xPU0VEJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NMT1NJTkcnIGluIHZhbCAmJlxuICAgICAgICAnQ09OTkVDVElORycgaW4gdmFsICYmXG4gICAgICAgICdPUEVOJyBpbiB2YWwpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *\n * common\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageType = exports.CloseCode = exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = void 0;\nexports.validateMessage = validateMessage;\nexports.isMessage = isMessage;\nexports.parseMessage = parseMessage;\nexports.stringifyMessage = stringifyMessage;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js\");\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nexports.GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nexports.DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (exports.CloseCode = CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (exports.MessageType = MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!(0, utils_1.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0, utils_1.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== 'string') {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !(0, utils_1.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0, utils_1.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0, utils_1.extendedTypeof)(val.payload)}`);\n            }\n            if (typeof val.payload.query !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !(0, utils_1.isObject)(val.payload.variables)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${(0, utils_1.extendedTypeof)(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                (0, utils_1.extendedTypeof)(val.payload.operationName) !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${(0, utils_1.extendedTypeof)(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !(0, utils_1.isObject)(val.payload.extensions)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${(0, utils_1.extendedTypeof)(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0, utils_1.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0, utils_1.extendedTypeof)(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0, utils_1.areGraphQLErrors)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0, utils_1.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nfunction isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHNDQUFzQyxHQUFHLHFDQUFxQztBQUN4SCx1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsZ0JBQWdCLG1CQUFPLENBQUMsa0hBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCLG1CQUFtQixtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlDQUFpQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHNDQUFzQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDJGQUEyRixZQUFZO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsb0NBQW9DO0FBQy9JO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsb0VBQW9FLHlDQUF5QztBQUMxSjtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMseUVBQXlFLCtDQUErQztBQUNySztBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsc0dBQXNHLG1EQUFtRDtBQUN0TTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx1R0FBdUcsdURBQXVEO0FBQzNNO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyx1R0FBdUcsb0RBQW9EO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsb0NBQW9DO0FBQy9JO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsb0VBQW9FLHlDQUF5QztBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELG9DQUFvQztBQUMvSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLHFGQUFxRiw0QkFBNEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDhEQUE4RCxvQ0FBb0M7QUFDL0k7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZWxsYXN1bW1lcmhpbGwvRGVza3RvcC9teWNyaXR0ZXJzL2thbmJhbi1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqXG4gKiBjb21tb25cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLkNsb3NlQ29kZSA9IGV4cG9ydHMuREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gZXhwb3J0cy5HUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCA9IHZvaWQgMDtcbmV4cG9ydHMudmFsaWRhdGVNZXNzYWdlID0gdmFsaWRhdGVNZXNzYWdlO1xuZXhwb3J0cy5pc01lc3NhZ2UgPSBpc01lc3NhZ2U7XG5leHBvcnRzLnBhcnNlTWVzc2FnZSA9IHBhcnNlTWVzc2FnZTtcbmV4cG9ydHMuc3RyaW5naWZ5TWVzc2FnZSA9IHN0cmluZ2lmeU1lc3NhZ2U7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgc3ViLXByb3RvY29sIHVzZWQgZm9yIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0cy5HUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCA9ICdncmFwaHFsLXRyYW5zcG9ydC13cyc7XG4vKipcbiAqIFRoZSBkZXByZWNhdGVkIHN1YnByb3RvY29sIHVzZWQgYnkgW3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzXShodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9zdWJzY3JpcHRpb25zLXRyYW5zcG9ydC13cykuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5ERVBSRUNBVEVEX0dSQVBIUUxfV1NfUFJPVE9DT0wgPSAnZ3JhcGhxbC13cyc7XG4vKipcbiAqIGBncmFwaHFsLXdzYCBleHBlY3RlZCBhbmQgc3RhbmRhcmQgY2xvc2UgY29kZXMgb2YgdGhlIFtHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sXShodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cC9ibG9iL21haW4vcmZjcy9HcmFwaFFMT3ZlcldlYlNvY2tldC5tZCkuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG52YXIgQ2xvc2VDb2RlO1xuKGZ1bmN0aW9uIChDbG9zZUNvZGUpIHtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDQ1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkludGVybmFsQ2xpZW50RXJyb3JcIl0gPSA0MDA1XSA9IFwiSW50ZXJuYWxDbGllbnRFcnJvclwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXF1ZXN0XCJdID0gNDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQmFkUmVzcG9uc2VcIl0gPSA0MDA0XSA9IFwiQmFkUmVzcG9uc2VcIjtcbiAgICAvKiogVHJpZWQgc3Vic2NyaWJpbmcgYmVmb3JlIGNvbm5lY3QgYWNrICovXG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlVuYXV0aG9yaXplZFwiXSA9IDQ0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiRm9yYmlkZGVuXCJdID0gNDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIl0gPSA0NDA2XSA9IFwiU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXRcIl0gPSA0NDA4XSA9IFwiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJDb25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dFwiXSA9IDQ1MDRdID0gXCJDb25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dFwiO1xuICAgIC8qKiBTdWJzY3JpYmVyIGRpc3RpbmN0aW9uIGlzIHZlcnkgaW1wb3J0YW50ICovXG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCJdID0gNDQwOV0gPSBcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCJdID0gNDQyOV0gPSBcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCI7XG59KShDbG9zZUNvZGUgfHwgKGV4cG9ydHMuQ2xvc2VDb2RlID0gQ2xvc2VDb2RlID0ge30pKTtcbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgYWxsb3dlZCB0byBiZSBzZW50IGJ5IHRoZSBjbGllbnQvc2VydmVyIG92ZXIgdGhlIFdTIHByb3RvY29sLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW1wiQ29ubmVjdGlvbkluaXRcIl0gPSBcImNvbm5lY3Rpb25faW5pdFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ29ubmVjdGlvbkFja1wiXSA9IFwiY29ubmVjdGlvbl9hY2tcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBpbmdcIl0gPSBcInBpbmdcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBvbmdcIl0gPSBcInBvbmdcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlN1YnNjcmliZVwiXSA9IFwic3Vic2NyaWJlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbXBsZXRlXCJdID0gXCJjb21wbGV0ZVwiO1xufSkoTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZVR5cGUgPSBNZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbWVzc2FnZSBhZ2FpbnN0IHRoZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sLlxuICpcbiAqIEludmFsaWQgbWVzc2FnZXMgd2lsbCB0aHJvdyBkZXNjcmlwdGl2ZSBlcnJvcnMuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2UodmFsKSB7XG4gICAgaWYgKCEoMCwgdXRpbHNfMS5pc09iamVjdCkodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbCl9YCk7XG4gICAgfVxuICAgIGlmICghdmFsLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGlzIG1pc3NpbmcgdGhlICd0eXBlJyBwcm9wZXJ0eWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0cyB0aGUgJ3R5cGUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbC50eXBlKX1gKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWwudHlwZSkge1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0OlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25BY2s6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUGluZzpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Qb25nOiB7XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQgIT0gbnVsbCAmJiAhKDAsIHV0aWxzXzEuaXNPYmplY3QpKHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgXCIke3ZhbC5wYXlsb2FkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN1YnNjcmliZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc09iamVjdCkodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHsoMCwgdXRpbHNfMS5leHRlbmRlZFR5cGVvZikodmFsLnBheWxvYWQucXVlcnkpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLnZhcmlhYmxlcyAhPSBudWxsICYmICEoMCwgdXRpbHNfMS5pc09iamVjdCkodmFsLnBheWxvYWQudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAndmFyaWFibGVzJyBwcm9wZXJ0eSB0byBiZSBhIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHsoMCwgdXRpbHNfMS5leHRlbmRlZFR5cGVvZikodmFsLnBheWxvYWQudmFyaWFibGVzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5leHRlbmRlZFR5cGVvZikodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdvcGVyYXRpb25OYW1lJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZyBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHsoMCwgdXRpbHNfMS5leHRlbmRlZFR5cGVvZikodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQuZXh0ZW5zaW9ucyAhPSBudWxsICYmICEoMCwgdXRpbHNfMS5pc09iamVjdCkodmFsLnBheWxvYWQuZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAkeygwLCB1dGlsc18xLmV4dGVuZGVkVHlwZW9mKSh2YWwucGF5bG9hZC5leHRlbnNpb25zKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc09iamVjdCkodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7KDAsIHV0aWxzXzEuZXh0ZW5kZWRUeXBlb2YpKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRXJyb3I6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAkeygwLCB1dGlsc18xLmV4dGVuZGVkVHlwZW9mKSh2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuYXJlR3JhcGhRTEVycm9ycykodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHsoMCwgdXRpbHNfMS5leHRlbmRlZFR5cGVvZikodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgJ3R5cGUnIHByb3BlcnR5IFwiJHt2YWwudHlwZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgdmFsaWQgR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBtZXNzYWdlLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgdmFsaWRhdGVNZXNzYWdlYCBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZnVuY3Rpb24gaXNNZXNzYWdlKHZhbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcmF3IHdlYnNvY2tldCBtZXNzYWdlIGRhdGEgdG8gYSB2YWxpZCBtZXNzYWdlLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKGRhdGEsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVNZXNzYWdlKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcikgOiBkYXRhKTtcbn1cbi8qKlxuICogU3RyaW5naWZpZXMgYSB2YWxpZCBtZXNzYWdlIHJlYWR5IHRvIGJlIHNlbnQgdGhyb3VnaCB0aGUgc29ja2V0LlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5TWVzc2FnZShtc2csIHJlcGxhY2VyKSB7XG4gICAgdmFsaWRhdGVNZXNzYWdlKG1zZyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1zZywgcmVwbGFjZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./client */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./server */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/server.js\"), exports);\n__exportStar(__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsb0hBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9IQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxvSEFBVSIsInNvdXJjZXMiOlsiL1VzZXJzL2VsbGFzdW1tZXJoaWxsL0Rlc2t0b3AvbXljcml0dGVycy9rYW5iYW4tYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL2dyYXBocWwtd3NANS4xNi4yX2dyYXBocWxAMTYuMTEuMC9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGllbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcnZlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/server.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/server.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n *\n * server\n *\n */\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeServer = makeServer;\nexports.handleProtocols = handleProtocols;\nconst graphql_1 = __webpack_require__(/*! graphql */ \"(ssr)/./node_modules/.pnpm/graphql@16.11.0/node_modules/graphql/index.mjs\");\nconst common_1 = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/common.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js\");\n/**\n * Makes a Protocol compliant WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Server\n */\nfunction makeServer(options) {\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\n    return {\n        opened(socket, extra) {\n            const ctx = {\n                connectionInitReceived: false,\n                acknowledged: false,\n                subscriptions: {},\n                extra,\n            };\n            if (socket.protocol !== common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n                socket.close(common_1.CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n                return async (code, reason) => {\n                    /* nothing was set up, just notify the closure */\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n                };\n            }\n            // kick the client off (close socket) if the connection has\n            // not been initialised after the specified wait timeout\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\n                ? setTimeout(() => {\n                    if (!ctx.connectionInitReceived)\n                        socket.close(common_1.CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n                }, connectionInitWaitTimeout)\n                : null;\n            socket.onMessage(async function onMessage(data) {\n                var _a, e_1, _b, _c;\n                var _d;\n                let message;\n                try {\n                    message = (0, common_1.parseMessage)(data, reviver);\n                }\n                catch (err) {\n                    return socket.close(common_1.CloseCode.BadRequest, 'Invalid message received');\n                }\n                switch (message.type) {\n                    case common_1.MessageType.ConnectionInit: {\n                        if (ctx.connectionInitReceived)\n                            return socket.close(common_1.CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                        // @ts-expect-error: I can write\n                        ctx.connectionInitReceived = true;\n                        if ((0, utils_1.isObject)(message.payload))\n                            // @ts-expect-error: I can write\n                            ctx.connectionParams = message.payload;\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n                        if (permittedOrPayload === false)\n                            return socket.close(common_1.CloseCode.Forbidden, 'Forbidden');\n                        // we should acknowledge before send to avoid race conditions (like those exampled in https://github.com/enisdenjo/graphql-ws/issues/501)\n                        // even if the send fails/throws, the connection should be closed because its malfunctioning\n                        // @ts-expect-error: I can write\n                        ctx.acknowledged = true;\n                        await socket.send((0, common_1.stringifyMessage)((0, utils_1.isObject)(permittedOrPayload)\n                            ? {\n                                type: common_1.MessageType.ConnectionAck,\n                                payload: permittedOrPayload,\n                            }\n                            : {\n                                type: common_1.MessageType.ConnectionAck,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        return;\n                    }\n                    case common_1.MessageType.Ping: {\n                        if (socket.onPing)\n                            // if the onPing listener is registered, automatic pong is disabled\n                            return await socket.onPing(message.payload);\n                        await socket.send((0, common_1.stringifyMessage)(message.payload\n                            ? { type: common_1.MessageType.Pong, payload: message.payload }\n                            : {\n                                type: common_1.MessageType.Pong,\n                                // payload is completely absent if not provided\n                            }));\n                        return;\n                    }\n                    case common_1.MessageType.Pong:\n                        return await ((_d = socket.onPong) === null || _d === void 0 ? void 0 : _d.call(socket, message.payload));\n                    case common_1.MessageType.Subscribe: {\n                        if (!ctx.acknowledged)\n                            return socket.close(common_1.CloseCode.Unauthorized, 'Unauthorized');\n                        const { id, payload } = message;\n                        if (id in ctx.subscriptions)\n                            return socket.close(common_1.CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                        // if this turns out to be a streaming operation, the subscription value\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\n                        ctx.subscriptions[id] = null;\n                        const emit = {\n                            next: async (result, args) => {\n                                let nextMessage = {\n                                    id,\n                                    type: common_1.MessageType.Next,\n                                    payload: result,\n                                };\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                                if (maybeResult)\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\n                                await socket.send((0, common_1.stringifyMessage)(nextMessage, replacer));\n                            },\n                            error: async (errors) => {\n                                let errorMessage = {\n                                    id,\n                                    type: common_1.MessageType.Error,\n                                    payload: errors,\n                                };\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                                if (maybeErrors)\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\n                                await socket.send((0, common_1.stringifyMessage)(errorMessage, replacer));\n                            },\n                            complete: async (notifyClient) => {\n                                const completeMessage = {\n                                    id,\n                                    type: common_1.MessageType.Complete,\n                                };\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                                if (notifyClient)\n                                    await socket.send((0, common_1.stringifyMessage)(completeMessage, replacer));\n                            },\n                        };\n                        try {\n                            let execArgs;\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                            if (maybeExecArgsOrErrors) {\n                                if ((0, utils_1.areGraphQLErrors)(maybeExecArgsOrErrors))\n                                    return id in ctx.subscriptions\n                                        ? await emit.error(maybeExecArgsOrErrors)\n                                        : void 0;\n                                else if (Array.isArray(maybeExecArgsOrErrors))\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                                // not errors, is exec args\n                                execArgs = maybeExecArgsOrErrors;\n                            }\n                            else {\n                                // you either provide a schema dynamically through\n                                // `onSubscribe` or you set one up during the server setup\n                                if (!schema)\n                                    throw new Error('The GraphQL schema is not provided');\n                                const args = {\n                                    operationName: payload.operationName,\n                                    document: (0, graphql_1.parse)(payload.query),\n                                    variableValues: payload.variables,\n                                };\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\n                                        ? await schema(ctx, message, args)\n                                        : schema });\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphql_1.validate)(execArgs.schema, execArgs.document);\n                                if (validationErrors.length > 0)\n                                    return id in ctx.subscriptions\n                                        ? await emit.error(validationErrors)\n                                        : void 0;\n                            }\n                            const operationAST = (0, graphql_1.getOperationAST)(execArgs.document, execArgs.operationName);\n                            if (!operationAST)\n                                return id in ctx.subscriptions\n                                    ? await emit.error([\n                                        new graphql_1.GraphQLError('Unable to identify operation'),\n                                    ])\n                                    : void 0;\n                            // if `onSubscribe` didn't specify a rootValue, inject one\n                            if (!('rootValue' in execArgs))\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                            // if `onSubscribe` didn't specify a context, inject one\n                            if (!('contextValue' in execArgs))\n                                execArgs.contextValue =\n                                    typeof context === 'function'\n                                        ? await context(ctx, message, execArgs)\n                                        : context;\n                            // the execution arguments have been prepared\n                            // perform the operation and act accordingly\n                            let operationResult;\n                            if (operationAST.operation === 'subscription')\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphql_1.subscribe)(execArgs);\n                            // operation === 'query' || 'mutation'\n                            else\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphql_1.execute)(execArgs);\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                            if (maybeResult)\n                                operationResult = maybeResult;\n                            if ((0, utils_1.isAsyncIterable)(operationResult)) {\n                                /** multiple emitted results */\n                                if (!(id in ctx.subscriptions)) {\n                                    // subscription was completed/canceled before the operation settled\n                                    if ((0, utils_1.isAsyncGenerator)(operationResult))\n                                        operationResult.return(undefined);\n                                }\n                                else {\n                                    ctx.subscriptions[id] = operationResult;\n                                    try {\n                                        for (var _e = true, operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), _a = operationResult_1_1.done, !_a; _e = true) {\n                                            _c = operationResult_1_1.value;\n                                            _e = false;\n                                            const result = _c;\n                                            await emit.next(result, execArgs);\n                                        }\n                                    }\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                    finally {\n                                        try {\n                                            if (!_e && !_a && (_b = operationResult_1.return)) await _b.call(operationResult_1);\n                                        }\n                                        finally { if (e_1) throw e_1.error; }\n                                    }\n                                }\n                            }\n                            else {\n                                /** single emitted result */\n                                // if the client completed the subscription before the single result\n                                // became available, he effectively canceled it and no data should be sent\n                                if (id in ctx.subscriptions)\n                                    await emit.next(operationResult, execArgs);\n                            }\n                            // lack of subscription at this point indicates that the client\n                            // completed the subscription, he doesn't need to be reminded\n                            await emit.complete(id in ctx.subscriptions);\n                        }\n                        finally {\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\n                            delete ctx.subscriptions[id];\n                        }\n                        return;\n                    }\n                    case common_1.MessageType.Complete: {\n                        const subscription = ctx.subscriptions[message.id];\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                        if ((0, utils_1.isAsyncGenerator)(subscription))\n                            await subscription.return(undefined);\n                        return;\n                    }\n                    default:\n                        throw new Error(`Unexpected message of type ${message.type} received`);\n                }\n            });\n            // wait for close, cleanup and the disconnect callback\n            return async (code, reason) => {\n                if (connectionInitWait)\n                    clearTimeout(connectionInitWait);\n                const subs = Object.assign({}, ctx.subscriptions);\n                // @ts-expect-error: I can write\n                ctx.subscriptions = {}; // deleting the subscription means no further activity should take place\n                // we return all iterable subscriptions immediatelly, independant of the order\n                await Promise.all(Object.values(subs)\n                    .filter(utils_1.isAsyncGenerator)\n                    .map((sub) => sub.return(undefined)));\n                if (ctx.acknowledged)\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n            };\n        },\n    };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nfunction handleProtocols(protocols) {\n    switch (true) {\n        case protocols instanceof Set &&\n            protocols.has(common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case Array.isArray(protocols) &&\n            protocols.includes(common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case typeof protocols === 'string' &&\n            protocols\n                .split(',')\n                .map((p) => p.trim())\n                .includes(common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL):\n            return common_1.GRAPHQL_TRANSPORT_WS_PROTOCOL;\n        default:\n            return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQywwRkFBUztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxvSEFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrSEFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwySkFBMko7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBLDhHQUE4RyxJQUFJO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixrQkFBa0Isc0JBQXNCO0FBQ3hIO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsbUJBQW1CLHNCQUFzQjtBQUMxSDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLDBGQUEwRjtBQUMvTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZWxsYXN1bW1lcmhpbGwvRGVza3RvcC9teWNyaXR0ZXJzL2thbmJhbi1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9zZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqXG4gKiBzZXJ2ZXJcbiAqXG4gKi9cbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ha2VTZXJ2ZXIgPSBtYWtlU2VydmVyO1xuZXhwb3J0cy5oYW5kbGVQcm90b2NvbHMgPSBoYW5kbGVQcm90b2NvbHM7XG5jb25zdCBncmFwaHFsXzEgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBNYWtlcyBhIFByb3RvY29sIGNvbXBsaWFudCBXZWJTb2NrZXQgR3JhcGhRTCBzZXJ2ZXIuIFRoZSBzZXJ2ZXJcbiAqIGlzIGFjdHVhbGx5IGFuIEFQSSB3aGljaCBpcyB0byBiZSB1c2VkIHdpdGggeW91ciBmYXZvdXJpdGUgV2ViU29ja2V0XG4gKiBzZXJ2ZXIgbGlicmFyeSFcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgdGhlIFtHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sXShodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cC9ibG9iL21haW4vcmZjcy9HcmFwaFFMT3ZlcldlYlNvY2tldC5tZCkuXG4gKlxuICogQGNhdGVnb3J5IFNlcnZlclxuICovXG5mdW5jdGlvbiBtYWtlU2VydmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgY29udGV4dCwgcm9vdHMsIHZhbGlkYXRlLCBleGVjdXRlLCBzdWJzY3JpYmUsIGNvbm5lY3Rpb25Jbml0V2FpdFRpbWVvdXQgPSAzMDAwLCAvLyAzIHNlY29uZHNcbiAgICBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgb25DbG9zZSwgb25TdWJzY3JpYmUsIG9uT3BlcmF0aW9uLCBvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGUsIGpzb25NZXNzYWdlUmV2aXZlcjogcmV2aXZlciwganNvbk1lc3NhZ2VSZXBsYWNlcjogcmVwbGFjZXIsIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9wZW5lZChzb2NrZXQsIGV4dHJhKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkluaXRSZWNlaXZlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc29ja2V0LnByb3RvY29sICE9PSBjb21tb25fMS5HUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlLCAnU3VicHJvdG9jb2wgbm90IGFjY2VwdGFibGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMgKGNvZGUsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBub3RoaW5nIHdhcyBzZXQgdXAsIGp1c3Qgbm90aWZ5IHRoZSBjbG9zdXJlICovXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNsb3NlID09PSBudWxsIHx8IG9uQ2xvc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2xvc2UoY3R4LCBjb2RlLCByZWFzb24pKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2ljayB0aGUgY2xpZW50IG9mZiAoY2xvc2Ugc29ja2V0KSBpZiB0aGUgY29ubmVjdGlvbiBoYXNcbiAgICAgICAgICAgIC8vIG5vdCBiZWVuIGluaXRpYWxpc2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgd2FpdCB0aW1lb3V0XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uSW5pdFdhaXQgPSBjb25uZWN0aW9uSW5pdFdhaXRUaW1lb3V0ID4gMCAmJiBpc0Zpbml0ZShjb25uZWN0aW9uSW5pdFdhaXRUaW1lb3V0KVxuICAgICAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3R4LmNvbm5lY3Rpb25Jbml0UmVjZWl2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoY29tbW9uXzEuQ2xvc2VDb2RlLkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXQsICdDb25uZWN0aW9uIGluaXRpYWxpc2F0aW9uIHRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uSW5pdFdhaXRUaW1lb3V0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHNvY2tldC5vbk1lc3NhZ2UoYXN5bmMgZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHZhciBfZDtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gKDAsIGNvbW1vbl8xLnBhcnNlTWVzc2FnZSkoZGF0YSwgcmV2aXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuQmFkUmVxdWVzdCwgJ0ludmFsaWQgbWVzc2FnZSByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbm5lY3Rpb25Jbml0UmVjZWl2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHMsICdUb28gbWFueSBpbml0aWFsaXNhdGlvbiByZXF1ZXN0cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogSSBjYW4gd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jb25uZWN0aW9uSW5pdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc09iamVjdCkobWVzc2FnZS5wYXlsb2FkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBJIGNhbiB3cml0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jb25uZWN0aW9uUGFyYW1zID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVybWl0dGVkT3JQYXlsb2FkID0gYXdhaXQgKG9uQ29ubmVjdCA9PT0gbnVsbCB8fCBvbkNvbm5lY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ29ubmVjdChjdHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJtaXR0ZWRPclBheWxvYWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuY2xvc2UoY29tbW9uXzEuQ2xvc2VDb2RlLkZvcmJpZGRlbiwgJ0ZvcmJpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGFja25vd2xlZGdlIGJlZm9yZSBzZW5kIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyAobGlrZSB0aG9zZSBleGFtcGxlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vZW5pc2RlbmpvL2dyYXBocWwtd3MvaXNzdWVzLzUwMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIHNlbmQgZmFpbHMvdGhyb3dzLCB0aGUgY29ubmVjdGlvbiBzaG91bGQgYmUgY2xvc2VkIGJlY2F1c2UgaXRzIG1hbGZ1bmN0aW9uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBJIGNhbiB3cml0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFja25vd2xlZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkoKDAsIHV0aWxzXzEuaXNPYmplY3QpKHBlcm1pdHRlZE9yUGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGVybWl0dGVkT3JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbW9uXzEuTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uXzEuTWVzc2FnZVR5cGUuUGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC5vblBpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9uUGluZyBsaXN0ZW5lciBpcyByZWdpc3RlcmVkLCBhdXRvbWF0aWMgcG9uZyBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBzb2NrZXQub25QaW5nKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLlBvbmcsIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uXzEuTWVzc2FnZVR5cGUuUG9uZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAoKF9kID0gc29ja2V0Lm9uUG9uZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoc29ja2V0LCBtZXNzYWdlLnBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb21tb25fMS5NZXNzYWdlVHlwZS5TdWJzY3JpYmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3R4LmFja25vd2xlZGdlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmNsb3NlKGNvbW1vbl8xLkNsb3NlQ29kZS5VbmF1dGhvcml6ZWQsICdVbmF1dGhvcml6ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgaW4gY3R4LnN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5jbG9zZShjb21tb25fMS5DbG9zZUNvZGUuU3Vic2NyaWJlckFscmVhZHlFeGlzdHMsIGBTdWJzY3JpYmVyIGZvciAke2lkfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyB0dXJucyBvdXQgdG8gYmUgYSBzdHJlYW1pbmcgb3BlcmF0aW9uLCB0aGUgc3Vic2NyaXB0aW9uIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGNoYW5nZSB0byBhbiBgQXN5bmNJdGVyYWJsZWAsIG90aGVyd2lzZSBpdCB3aWxsIHN0YXkgYXMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpcHRpb25zW2lkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbWl0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGFzeW5jIChyZXN1bHQsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb21tb25fMS5NZXNzYWdlVHlwZS5OZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVJlc3VsdCA9IGF3YWl0IChvbk5leHQgPT09IG51bGwgfHwgb25OZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk5leHQoY3R4LCBuZXh0TWVzc2FnZSwgYXJncywgcmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNZXNzYWdlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXh0TWVzc2FnZSksIHsgcGF5bG9hZDogbWF5YmVSZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNvY2tldC5zZW5kKCgwLCBjb21tb25fMS5zdHJpbmdpZnlNZXNzYWdlKShuZXh0TWVzc2FnZSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBhc3luYyAoZXJyb3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZUVycm9ycyA9IGF3YWl0IChvbkVycm9yID09PSBudWxsIHx8IG9uRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXJyb3IoY3R4LCBlcnJvck1lc3NhZ2UsIGVycm9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yTWVzc2FnZSksIHsgcGF5bG9hZDogbWF5YmVFcnJvcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNvY2tldC5zZW5kKCgwLCBjb21tb25fMS5zdHJpbmdpZnlNZXNzYWdlKShlcnJvck1lc3NhZ2UsIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogYXN5bmMgKG5vdGlmeUNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAob25Db21wbGV0ZSA9PT0gbnVsbCB8fCBvbkNvbXBsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbXBsZXRlKGN0eCwgY29tcGxldGVNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RpZnlDbGllbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzb2NrZXQuc2VuZCgoMCwgY29tbW9uXzEuc3RyaW5naWZ5TWVzc2FnZSkoY29tcGxldGVNZXNzYWdlLCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhlY0FyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVFeGVjQXJnc09yRXJyb3JzID0gYXdhaXQgKG9uU3Vic2NyaWJlID09PSBudWxsIHx8IG9uU3Vic2NyaWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblN1YnNjcmliZShjdHgsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVFeGVjQXJnc09yRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5hcmVHcmFwaFFMRXJyb3JzKShtYXliZUV4ZWNBcmdzT3JFcnJvcnMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkIGluIGN0eC5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBlbWl0LmVycm9yKG1heWJlRXhlY0FyZ3NPckVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtYXliZUV4ZWNBcmdzT3JFcnJvcnMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHVybiB2YWx1ZSBmcm9tIG9uU3Vic2NyaWJlIGhvb2ssIGV4cGVjdGVkIGFuIGFycmF5IG9mIEdyYXBoUUxFcnJvciBvYmplY3RzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlcnJvcnMsIGlzIGV4ZWMgYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjQXJncyA9IG1heWJlRXhlY0FyZ3NPckVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlvdSBlaXRoZXIgcHJvdmlkZSBhIHNjaGVtYSBkeW5hbWljYWxseSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBvblN1YnNjcmliZWAgb3IgeW91IHNldCBvbmUgdXAgZHVyaW5nIHRoZSBzZXJ2ZXIgc2V0dXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBHcmFwaFFMIHNjaGVtYSBpcyBub3QgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IHBheWxvYWQub3BlcmF0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiAoMCwgZ3JhcGhxbF8xLnBhcnNlKShwYXlsb2FkLnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWVzOiBwYXlsb2FkLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0FyZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZ3MpLCB7IHNjaGVtYTogdHlwZW9mIHNjaGVtYSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXdhaXQgc2NoZW1hKGN0eCwgbWVzc2FnZSwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNjaGVtYSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9ICh2YWxpZGF0ZSAhPT0gbnVsbCAmJiB2YWxpZGF0ZSAhPT0gdm9pZCAwID8gdmFsaWRhdGUgOiBncmFwaHFsXzEudmFsaWRhdGUpKGV4ZWNBcmdzLnNjaGVtYSwgZXhlY0FyZ3MuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkIGluIGN0eC5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBlbWl0LmVycm9yKHZhbGlkYXRpb25FcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbkFTVCA9ICgwLCBncmFwaHFsXzEuZ2V0T3BlcmF0aW9uQVNUKShleGVjQXJncy5kb2N1bWVudCwgZXhlY0FyZ3Mub3BlcmF0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb25BU1QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCBpbiBjdHguc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBlbWl0LmVycm9yKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZ3JhcGhxbF8xLkdyYXBoUUxFcnJvcignVW5hYmxlIHRvIGlkZW50aWZ5IG9wZXJhdGlvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGBvblN1YnNjcmliZWAgZGlkbid0IHNwZWNpZnkgYSByb290VmFsdWUsIGluamVjdCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgncm9vdFZhbHVlJyBpbiBleGVjQXJncykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNBcmdzLnJvb3RWYWx1ZSA9IHJvb3RzID09PSBudWxsIHx8IHJvb3RzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290c1tvcGVyYXRpb25BU1Qub3BlcmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBgb25TdWJzY3JpYmVgIGRpZG4ndCBzcGVjaWZ5IGEgY29udGV4dCwgaW5qZWN0IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCdjb250ZXh0VmFsdWUnIGluIGV4ZWNBcmdzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0FyZ3MuY29udGV4dFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBjb250ZXh0KGN0eCwgbWVzc2FnZSwgZXhlY0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBleGVjdXRpb24gYXJndW1lbnRzIGhhdmUgYmVlbiBwcmVwYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhbmQgYWN0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9wZXJhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uQVNULm9wZXJhdGlvbiA9PT0gJ3N1YnNjcmlwdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3VsdCA9IGF3YWl0IChzdWJzY3JpYmUgIT09IG51bGwgJiYgc3Vic2NyaWJlICE9PSB2b2lkIDAgPyBzdWJzY3JpYmUgOiBncmFwaHFsXzEuc3Vic2NyaWJlKShleGVjQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uID09PSAncXVlcnknIHx8ICdtdXRhdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3VsdCA9IGF3YWl0IChleGVjdXRlICE9PSBudWxsICYmIGV4ZWN1dGUgIT09IHZvaWQgMCA/IGV4ZWN1dGUgOiBncmFwaHFsXzEuZXhlY3V0ZSkoZXhlY0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlUmVzdWx0ID0gYXdhaXQgKG9uT3BlcmF0aW9uID09PSBudWxsIHx8IG9uT3BlcmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZXJhdGlvbihjdHgsIG1lc3NhZ2UsIGV4ZWNBcmdzLCBvcGVyYXRpb25SZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVSZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3VsdCA9IG1heWJlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0FzeW5jSXRlcmFibGUpKG9wZXJhdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIG11bHRpcGxlIGVtaXR0ZWQgcmVzdWx0cyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpZCBpbiBjdHguc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiB3YXMgY29tcGxldGVkL2NhbmNlbGVkIGJlZm9yZSB0aGUgb3BlcmF0aW9uIHNldHRsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0FzeW5jR2VuZXJhdG9yKShvcGVyYXRpb25SZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3VsdC5yZXR1cm4odW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpcHRpb25zW2lkXSA9IG9wZXJhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBvcGVyYXRpb25SZXN1bHRfMSA9IF9fYXN5bmNWYWx1ZXMob3BlcmF0aW9uUmVzdWx0KSwgb3BlcmF0aW9uUmVzdWx0XzFfMTsgb3BlcmF0aW9uUmVzdWx0XzFfMSA9IGF3YWl0IG9wZXJhdGlvblJlc3VsdF8xLm5leHQoKSwgX2EgPSBvcGVyYXRpb25SZXN1bHRfMV8xLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gb3BlcmF0aW9uUmVzdWx0XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGVtaXQubmV4dChyZXN1bHQsIGV4ZWNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gb3BlcmF0aW9uUmVzdWx0XzEucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChvcGVyYXRpb25SZXN1bHRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIHNpbmdsZSBlbWl0dGVkIHJlc3VsdCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IGNvbXBsZXRlZCB0aGUgc3Vic2NyaXB0aW9uIGJlZm9yZSB0aGUgc2luZ2xlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhbWUgYXZhaWxhYmxlLCBoZSBlZmZlY3RpdmVseSBjYW5jZWxlZCBpdCBhbmQgbm8gZGF0YSBzaG91bGQgYmUgc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgaW4gY3R4LnN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBlbWl0Lm5leHQob3BlcmF0aW9uUmVzdWx0LCBleGVjQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhY2sgb2Ygc3Vic2NyaXB0aW9uIGF0IHRoaXMgcG9pbnQgaW5kaWNhdGVzIHRoYXQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCB0aGUgc3Vic2NyaXB0aW9uLCBoZSBkb2Vzbid0IG5lZWQgdG8gYmUgcmVtaW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBlbWl0LmNvbXBsZXRlKGlkIGluIGN0eC5zdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXRldmVyIGhhcHBlbnMgdG8gdGhlIHN1YnNjcmlwdGlvbiwgd2UgZmluYWxseSB3YW50IHRvIGdldCByaWQgb2YgdGhlIHJlc2VydmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGN0eC5zdWJzY3JpcHRpb25zW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vbl8xLk1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjdHguc3Vic2NyaXB0aW9uc1ttZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdHguc3Vic2NyaXB0aW9uc1ttZXNzYWdlLmlkXTsgLy8gZGVsZXRpbmcgdGhlIHN1YnNjcmlwdGlvbiBtZWFucyBubyBmdXJ0aGVyIGFjdGl2aXR5IHNob3VsZCB0YWtlIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNBc3luY0dlbmVyYXRvcikoc3Vic2NyaXB0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdWJzY3JpcHRpb24ucmV0dXJuKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIG9mIHR5cGUgJHttZXNzYWdlLnR5cGV9IHJlY2VpdmVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciBjbG9zZSwgY2xlYW51cCBhbmQgdGhlIGRpc2Nvbm5lY3QgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiBhc3luYyAoY29kZSwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25Jbml0V2FpdClcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25Jbml0V2FpdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VicyA9IE9iamVjdC5hc3NpZ24oe30sIGN0eC5zdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBJIGNhbiB3cml0ZVxuICAgICAgICAgICAgICAgIGN0eC5zdWJzY3JpcHRpb25zID0ge307IC8vIGRlbGV0aW5nIHRoZSBzdWJzY3JpcHRpb24gbWVhbnMgbm8gZnVydGhlciBhY3Rpdml0eSBzaG91bGQgdGFrZSBwbGFjZVxuICAgICAgICAgICAgICAgIC8vIHdlIHJldHVybiBhbGwgaXRlcmFibGUgc3Vic2NyaXB0aW9ucyBpbW1lZGlhdGVsbHksIGluZGVwZW5kYW50IG9mIHRoZSBvcmRlclxuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoc3VicylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih1dGlsc18xLmlzQXN5bmNHZW5lcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHN1YikgPT4gc3ViLnJldHVybih1bmRlZmluZWQpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5hY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkRpc2Nvbm5lY3QgPT09IG51bGwgfHwgb25EaXNjb25uZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRpc2Nvbm5lY3QoY3R4LCBjb2RlLCByZWFzb24pKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25DbG9zZSA9PT0gbnVsbCB8fCBvbkNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNsb3NlKGN0eCwgY29kZSwgcmVhc29uKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEhlbHBlciB1dGlsaXR5IGZvciBjaG9vc2luZyB0aGUgXCJncmFwaHFsLXRyYW5zcG9ydC13c1wiIHN1YnByb3RvY29sIGZyb21cbiAqIGEgc2V0IG9mIFdlYlNvY2tldCBzdWJwcm90b2NvbHMuXG4gKlxuICogQWNjZXB0cyBhIHNldCBvZiBhbHJlYWR5IGV4dHJhY3RlZCBXZWJTb2NrZXQgc3VicHJvdG9jb2xzIG9yIHRoZSByYXdcbiAqIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyIHZhbHVlLiBJbiBlaXRoZXIgY2FzZSwgaWYgdGhlIHJpZ2h0XG4gKiBwcm90b2NvbCBhcHBlYXJzLCBpdCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEJ5IHNwZWNpZmljYXRpb24sIHRoZSBzZXJ2ZXIgc2hvdWxkIG5vdCBwcm92aWRlIGEgdmFsdWUgd2l0aCBTZWMtV2ViU29ja2V0LVByb3RvY29sXG4gKiBpZiBpdCBkb2VzIG5vdCBhZ3JlZSB3aXRoIGNsaWVudCdzIHN1YnByb3RvY29scy4gVGhlIGNsaWVudCBoYXMgYSByZXNwb25zaWJpbGl0eVxuICogdG8gaGFuZGxlIHRoZSBjb25uZWN0aW9uIGFmdGVyd2FyZHMuXG4gKlxuICogQGNhdGVnb3J5IFNlcnZlclxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgcHJvdG9jb2xzIGluc3RhbmNlb2YgU2V0ICYmXG4gICAgICAgICAgICBwcm90b2NvbHMuaGFzKGNvbW1vbl8xLkdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MKTpcbiAgICAgICAgY2FzZSBBcnJheS5pc0FycmF5KHByb3RvY29scykgJiZcbiAgICAgICAgICAgIHByb3RvY29scy5pbmNsdWRlcyhjb21tb25fMS5HUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCk6XG4gICAgICAgIGNhc2UgdHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHByb3RvY29sc1xuICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgLm1hcCgocCkgPT4gcC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmluY2x1ZGVzKGNvbW1vbl8xLkdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MKTpcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5HUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendedTypeof = extendedTypeof;\nexports.isObject = isObject;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.areGraphQLErrors = areGraphQLErrors;\nexports.limitCloseReason = limitCloseReason;\n/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nfunction isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A1LjE2LjJfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbGxhc3VtbWVyaGlsbC9EZXNrdG9wL215Y3JpdHRlcnMva2FuYmFuLWJvYXJkL25vZGVfbW9kdWxlcy8ucG5wbS9ncmFwaHFsLXdzQDUuMTYuMl9ncmFwaHFsQDE2LjExLjAvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRlZFR5cGVvZiA9IGV4dGVuZGVkVHlwZW9mO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSBpc0FzeW5jSXRlcmFibGU7XG5leHBvcnRzLmlzQXN5bmNHZW5lcmF0b3IgPSBpc0FzeW5jR2VuZXJhdG9yO1xuZXhwb3J0cy5hcmVHcmFwaFFMRXJyb3JzID0gYXJlR3JhcGhRTEVycm9ycztcbmV4cG9ydHMubGltaXRDbG9zZVJlYXNvbiA9IGxpbWl0Q2xvc2VSZWFzb247XG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGV4dGVuZGVkVHlwZW9mKHZhbCkge1xuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG59XG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBleHRlbmRlZFR5cGVvZih2YWwpID09PSAnb2JqZWN0Jztcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKHZhbCkge1xuICAgIHJldHVybiAoaXNPYmplY3QodmFsKSAmJlxuICAgICAgICB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWwucmV0dXJuID09PSAnZnVuY3Rpb24nXG4gICAgLy8gZm9yIGxhenkgb25lcywgd2Ugb25seSBuZWVkIHRoZSByZXR1cm4gYW55d2F5XG4gICAgLy8gdHlwZW9mIHZhbC50aHJvdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIC8vIHR5cGVvZiB2YWwubmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG59XG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGFyZUdyYXBoUUxFcnJvcnMob2JqKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAgICAgLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmUgZXJyb3JcbiAgICAgICAgb2JqLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgLy8gZXJyb3IgaGFzIGF0IGxlYXN0IGEgbWVzc2FnZVxuICAgICAgICBvYmouZXZlcnkoKG9iKSA9PiAnbWVzc2FnZScgaW4gb2IpKTtcbn1cbi8qKlxuICogTGltaXRzIHRoZSBXZWJTb2NrZXQgY2xvc2UgZXZlbnQgcmVhc29uIHRvIG5vdCBleGNlZWQgYSBsZW5ndGggb2Ygb25lIGZyYW1lLlxuICogUmVmZXJlbmNlOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gICAgcmV0dXJuIHJlYXNvbi5sZW5ndGggPCAxMjQgPyByZWFzb24gOiB3aGVuVG9vTG9uZztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@5.16.2_graphql@16.11.0/node_modules/graphql-ws/lib/utils.js\n");

/***/ })

};
;